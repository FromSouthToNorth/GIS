<template>
  <MarkDown />
  <MarkdownViewer :value="value" />
</template>

<script setup>
import {MarkDown, MarkdownViewer} from "/@/components/Markdown";
import {ref} from "vue";
const value = ref('# 递归与动态规划\n' +
  '\n' +
  '[剑指 Offer 10- I. 斐波那契数列](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/description/)\n' +
  '\n' +
  '- $F_0 = 0$\n' +
  '  \n' +
  '- $F_1=1$\n' +
  '  \n' +
  '- $F_n = F_n-1 + F_n-2$ (n≧2)\n' +
  '  \n' +
  '\n' +
  '## 因此获得递归函数 $f(n)$\n' +
  '\n' +
  '```java\n' +
  'class Solution {\n' +
  '\n' +
  '    public int f(int n) {\n' +
  '        if (n < 2) {\n' +
  '            return n;\n' +
  '        }\n' +
  '        return f(n - 1) + f(n - 2) % 1000000007;\n' +
  '    }\n' +
  '\n' +
  '}\n' +
  '```\n' +
  '\n' +
  '### 但是当递归函数 $f(n)$ 输入规模过大 ，比如 当输入 $n=44$ 执行示例就会超时。所以递归并不是最优解\n' +
  '\n' +
  '### 函数 $f(n)$ 举例深度为 3 的递归二叉树\n' +
  '\n' +
  '![](https://202007002.oss-cn-chengdu.aliyuncs.com/images/%E9%80%92%E5%BD%92%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%80%92%E5%BD%92%E6%A0%91.png)\n' +
  '\n' +
  '> 从递归方法的调用树轨迹来看，$f(42-1),f(42-2),f(41-1),f(41-2)$ 执行了重复计算\n' +
  '> \n' +
  '> 时间复杂度: $O(n^2)$\n' +
  '> \n' +
  '> 空间复杂度: $O(n)$\n' +
  '\n' +
  '## 优化\n' +
  '\n' +
  '### 当我们知道上面方法存在着随着输入规模 $n$ 的数量越大，进行重复计算的越多。间复杂度也就越高\n' +
  '\n' +
  '> 我们能不能想个办法，把第一次计算的值缓存下来，当每次发生重复计算时直接去取。\n' +
  '> \n' +
  '> 或者说程序运行时可能需将当前的状态，转移到另一个状态，所以需要存储程序第一运行的状态，方便进行状态转移\n' +
  '\n' +
  '#### 声明一个名为 $dp$ 的数组，用来存放第一次计算的值\n' +
  '\n' +
  '```java\n' +
  'int[] dp = new int[n + 1];\n' +
  '```\n' +
  '\n' +
  '> 数组的长度为 输入规模 + 1\n' +
  '\n' +
  '#### 并赋予初始下标 $[0,1]$ 为 0 和 1\n' +
  '\n' +
  '```java\n' +
  'dp[0] = 0;\n' +
  'dp[1] = 1;\n' +
  '```\n' +
  '\n' +
  '### 循环输入规模，并把每次计算的结果存入 $dp$ 数组中\n' +
  '\n' +
  '```java\n' +
  'for (int i = 2; i <= n; i++) {\n' +
  '    dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;\n' +
  '}\n' +
  '```\n' +
  '\n' +
  '> $for$ 循环 的下标从二 开始 是因为 前面已经赋予下标 $0,1$ 初始值。而且每一次的计算需依赖上一次的结果。\n' +
  '> \n' +
  '> 这里做所以需要 $mod$ $10^9 + 7$ 是为了防止计算的结果过大溢出\n' +
  '\n' +
  '#### $f(n)$ 的返回值\n' +
  '\n' +
  '```java\n' +
  'return dp[n];\n' +
  '```\n' +
  '\n' +
  '> 返回下标为输入规模的值即可\n' +
  '\n' +
  '#### 完整代码\n' +
  '\n' +
  '```java\n' +
  'public int f(int n) {\n' +
  '    if (n < 2) {\n' +
  '        return n;    \n' +
  '    }\n' +
  '    int[] dp = new int[n + 1];\n' +
  '    for (int i = 2; i <= n; i++) {\n' +
  '        dp[i] = dp[i - 1] + dp[i - 2] % 1000000007;\n' +
  '    }\n' +
  '    return dp[n];    \n' +
  '}\n' +
  '```\n' +
  '\n' +
  '> 时间复杂度：方法的调用并没有逐渐上涨，只访问 $dp$ 数组中的元素。所以是 $O(n)$\n' +
  '> \n' +
  '> 空间复杂度：根据输入 $n$ 创建对应的数组。所以是 $O(n)$\n' +
  '\n' +
  '### 总结\n' +
  '\n' +
  '> 关于递归和动态规划。\n' +
  '> \n' +
  '> - 递归的时间复杂度会伴随着的调用次数成上涨趋势\n' +
  '>   \n' +
  '> - 使用递归最好画出递归的调用图(类似于上面的递归调用二叉树)\n' +
  '>   \n' +
  '> - 寻找递归调用的相同计算和 (不变的) 规律\n' +
  '>   \n' +
  '> - 寻找随着递归调用而变化的参数\n' +
  '>   \n' +
  '> - 抽离出来，进行统一的处理（缓存记录）\n' +
  '>')
</script>

<style scoped>

</style>
